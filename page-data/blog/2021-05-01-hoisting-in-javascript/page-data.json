{"componentChunkName":"component---src-components-blog-layout-js","path":"/blog/2021-05-01-hoisting-in-javascript/","result":{"data":{"mdx":{"id":"30fb643d-455a-5be3-bc7a-2545a9997f0e","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Hoisting in JavaScript\",\n  \"date\": \"2021-05-01T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"On a high level, JavaScript code goes through two phases: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"compilation\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"execution\"), \". I say \\\"on a high level\\\" because there will actually be some more things going on under the hood. See \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stackoverflow.com/a/51447411/5774633\"\n  }), \"this answer\"), \" on StackOverflow for a quick overview of what else happens in Chrome's V8 engine.\"), mdx(\"p\", null, \"Hoisting happens during the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"compilation\"), \" phase. Function declarations and variables defined using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" keyword are moved to the top of their scope.\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \" This allows for weird things to happen like calling a function before it is defined.\"), mdx(\"h3\", null, \"Hoisting of functions\"), mdx(\"p\", null, \"Doing this in Python would give you an error:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# hello.py\\n\\nsay_hello()\\n\\ndef say_hello():\\n  print(\\\"Hello!\\\")\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"$ python3 hello.py\\nTraceback (most recent call last):\\n  File \\\"hello.py\\\", line 1, in <module>\\n    say_hello()\\nNameError: name 'say_hello' is not defined\\n\")), mdx(\"p\", null, \"But, it works perfectly fine in JavaScript!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// hello.js\\n\\nsayHello();\\n\\nfunction sayHello() {\\n  console.log(\\\"Hello!\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"$ node hello.js\\nHello!\\n\")), mdx(\"p\", null, \"This is because the function is hoisted to the top of its scope. i.e. when execution of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hello.js\"), \" begins, the definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sayHello\"), \" is put into memory during the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"compilation\"), \" phase.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Function expressions\"), \", however, are not hoisted.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// hello2.js\\n\\nsayHello();\\n\\nvar sayHello = function() {\\n  console.log(\\\"Hello!\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"$ node hello2.js\\n\\nsayHello();\\n^\\n\\nTypeError: sayHello is not a function\\n  ...\\n  ...\\n  ...\\n\")), mdx(\"h3\", null, \"Hoisting of multiple functions with same name\"), mdx(\"p\", null, \"If there are multiple functions with the same name, they are hoisted in the order they are defined.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// multifunc.js\\n\\nfunction foo() {\\n  console.log(\\\"bar\\\");\\n}\\n\\nfoo();\\n\\nfunction foo() {\\n  console.log(\\\"baz\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"$ node multifunc.js \\nbaz\\n\")), mdx(\"p\", null, \"During the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"compilation\"), \" phase, the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" is loaded into memory. Then, the second one is loaded which overwrites the first one. Therefore, when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo()\"), \" is called during the execution phase, the second function is executed.\"), mdx(\"h3\", null, \"Hoisting of variables\"), mdx(\"p\", null, \"Variables declared using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" keyword are hoisted to the top of the scope. However, only the declarations are hoisted and if there are any initializations, they remain exactly where they are.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// foobar.js\\n\\nconsole.log(foo);\\nvar foo = \\\"bar\\\";\\nconsole.log(foo);\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"$ node foobar.js \\nundefined\\nbar\\n\")), mdx(\"p\", null, \"Since only the declaration of the variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" is hoisted, the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" statement logs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".\"), mdx(\"p\", null, \"Then, the variable is assigned the value \\\"bar\\\" which the next \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" statement logs.\"), mdx(\"h3\", null, \"Hoisting of variable and function with the same name\"), mdx(\"p\", null, \"If there is a variable declared using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" keyword and a function definition with the same name in a scope, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"only the function is hoisted\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// varfunc.js\\n\\nconsole.log(foo);\\n\\nfunction foo() {\\n  console.log(\\\"baz\\\");\\n}\\n\\nvar foo = \\\"bar\\\";\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"$ node varfunc.js\\n[Function: foo]\\n\")), mdx(\"h2\", null, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://javascript.info/var\"\n  }), \"The old \\\"var\\\" (javascript.info)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.freecodecamp.org/news/function-hoisting-hoisting-interview-questions-b6f91dbc2be8/\"\n  }), \"Function Hoisting & Hoisting Interview Questions (freecodecamp.org)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\"\n  }), \"Hoisting - MDN Web Docs Glossary\"))), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-1\"\n  }), \"As described in the \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\"\n  }), \"MDN glossary entry for Hoisting\"), \", variables and functions being hoisted are not physically moved. They stay exactly where they are typed in the source code; their definitions are put into memory during the compilation phase.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Hoisting in JavaScript"}}},"pageContext":{"id":"30fb643d-455a-5be3-bc7a-2545a9997f0e"}},"staticQueryHashes":["3069025275","63159454"]}