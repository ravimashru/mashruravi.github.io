{"componentChunkName":"component---src-components-blog-layout-js","path":"/blog/2021-04-18-fp-java/","result":{"data":{"mdx":{"id":"b290be22-dc76-56d7-af91-63f50089e5c2","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Functional Programming in Java with Functional Interfaces, Anonymous Classes and Lambda Expressions\",\n  \"date\": \"2021-04-18T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Functional programming requires the use of, well... functions. Methods in Java can play the role of a function is they are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"pure\"), \" - they have no side effects, and they always return the same value when called with the same arguments.\"), mdx(\"p\", null, \"However, using methods this way doesn't allow for composition of functions which requires passing a function as a parameter to another function. Functional interfaces allow for the composition of function.\"), mdx(\"p\", null, \"Technically, functional interfaces are interfaces with one abstract method.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public interface Function<T, R> {\\n\\n    R apply(T t);\\n\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"An example of an inbuilt functional interface \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"Function\"), \" with an abstract method \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"apply\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"java.util.function\"), \".\")), mdx(\"p\", null, \"Let's say we have an array of integers 1 to 5. We want to:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Square each integer\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Remove the odd results\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Find the sum of the remaining numbers\")), mdx(\"p\", null, \"This can be done using the functional programming paradigm by composing functions that do each of those things as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.function.Function;\\n\\npublic class FunctionalInterfacesDemo {\\n\\n    public static void main(String[] args) {\\n\\n        List<Integer> numbers = new ArrayList<Integer>(List.of(1, 2, 3, 4, 5));\\n\\n        Function<List<Integer>, List<Integer>> square = new Function<List<Integer>, List<Integer>>() {\\n\\n            @Override\\n            public List<Integer> apply(List<Integer> arr) {\\n                List<Integer> res = new ArrayList<Integer>();\\n                for (Integer i : arr) {\\n                    res.add(i * i);\\n                }\\n                return res;\\n            }\\n\\n        };\\n\\n        Function<List<Integer>, List<Integer>> keepEven = new Function<List<Integer>, List<Integer>>() {\\n\\n            @Override\\n            public List<Integer> apply(List<Integer> arr) {\\n                List<Integer> res = new ArrayList<Integer>();\\n                for (Integer i : arr) {\\n                    if (i % 2 == 0) {\\n                        res.add(i);\\n                    }\\n                }\\n                return res;\\n            }\\n\\n        };\\n\\n        Function<List<Integer>, Integer> sum = new Function<List<Integer>, Integer>() {\\n\\n            @Override\\n            public Integer apply(List<Integer> arr) {\\n                Integer res = 0;\\n                for (Integer i : arr) {\\n                    res += i;\\n                }\\n                return res;\\n            }\\n\\n        };\\n\\n        Function<List<Integer>, Integer> squareKeepEvenSum = sum.compose(keepEven).compose(square);\\n\\n        System.out.println(squareKeepEvenSum.apply(numbers));\\n        // Output: 20\\n\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"Notice that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"square\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keepEven\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \" objects are of the class defined inline on the right-hand side of the assignment. Since the class doesn't have a name, it is called an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"anonymous class\"), \".\"), mdx(\"p\", null, \"Creating an object of an anonymous class this way can reduce the time and effort required to create classes that implement functional interfaces in a separate file and then create objects of them.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lambdas\"), \" make it even less verbose to implement functional interfaces. We can redo the above example using lambdas instead of anonymous classes as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.function.Function;\\n\\npublic class FunctionalInterfacesLambdaDemo {\\n\\n    public static void main(String[] args) {\\n        List<Integer> numbers = new ArrayList<Integer>(List.of(1, 2, 3, 4, 5));\\n\\n        Function<List<Integer>, List<Integer>> square = arr -> {\\n            List<Integer> res = new ArrayList<Integer>();\\n            for (Integer i : arr) {\\n                res.add(i * i);\\n            }\\n            return res;\\n        };\\n\\n        Function<List<Integer>, List<Integer>> keepEven = arr -> {\\n            List<Integer> res = new ArrayList<Integer>();\\n            for (Integer i : arr) {\\n                if (i % 2 == 0) {\\n                    res.add(i);\\n                }\\n            }\\n            return res;\\n        };\\n\\n        Function<List<Integer>, Integer> sum = arr -> {\\n            Integer res = 0;\\n            for (Integer i : arr) {\\n                res += i;\\n            }\\n            return res;\\n        };\\n\\n        Function<List<Integer>, Integer> squareKeepEvenSum = sum.compose(keepEven).compose(square);\\n\\n        System.out.println(squareKeepEvenSum.apply(numbers));\\n        // Output: 20\\n\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"In addition to a simpler syntax, lambdas allow us to skip writing the type of the parameter since Java can infer the type from the interface.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Functional Programming in Java with Functional Interfaces, Anonymous Classes and Lambda Expressions"}}},"pageContext":{"id":"b290be22-dc76-56d7-af91-63f50089e5c2"}},"staticQueryHashes":["3069025275","63159454"]}