{"componentChunkName":"component---src-components-blog-layout-js","path":"/blog/2021-09-09-superconvergence/","result":{"data":{"mdx":{"id":"c8ae31f1-fd24-5d9c-9e4f-6253caebba70","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Understanding Super-Convergence\",\n  \"date\": \"2021-09-09T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this blog post, we will take a look at the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://arxiv.org/abs/1708.07120\"\n  }), \"Super-Convergence\"), \" research paper and try to understand:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The meaning and benefits of super-convergence\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Practical considerations when using super-convergence\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How to use super-convergence with the fast.ai library\")), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, \"Neural networks are trained using an algorithm called stochastic gradient descent (SGD). SGD is an iterative method that calculates the direction in which we need to update the parameters of the network so that its performance improves. We then update the parameters of the network accordingly.\"), mdx(\"p\", null, \"When updating the parameters, we use a parameter called the learning rate to control the size of the steps we take when updating the parameters during SGD. A higher learning rate results in larger updates to a network's parameters.\"), mdx(\"p\", null, \"Higher learning rates allow us to train networks faster. However, since we start with randomly initialized weights, if we start training with a high learning rate then our neural network will not learn. Also, if we end training with a high learning rate then there is a chance that our network won't settle at a minima.\"), mdx(\"p\", null, \"So we want to start and end training neural networks with a low learning rate, but use a high learning rate in between. Leslie Smith proposes a method that behaves just like this in this paper, and calls it the 1cycle training policy.\"), mdx(\"h2\", null, \"The 1cycle training policy\"), mdx(\"p\", null, \"In the 1cycle training policy, we start training a neural network with a very small learning rate. We increase the learning rate linearly with each batch until it reaches a maximum value (this is called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"warmup\"), \" phase). We then decrease the learning rate until it reaches the initial learning rate value (this is called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"annealing\"), \" phase). The paper then advises us to continue training the model for a few more epochs while reducing the learning from the value we started with to one several orders of magnitude lower.\"), mdx(\"p\", null, \"If we were to plot the learning rate we use to train the network against training iterations, we would get something like this:\"), mdx(Image, {\n    name: \"1cycle.png\",\n    mdxType: \"Image\"\n  }), mdx(\"h2\", null, \"Benefits of super-convergence\"), mdx(\"p\", null, \"Using the 1cycle policy allows training with much higher learning rates than usual. As a result, neural networks tend to train much faster than usual. This is what Leslie Smith refers to as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"super-convergence\"), \" in the paper.\"), mdx(\"p\", null, \"Also, using high learning rates allows the network to bypass local minima and move towards smoother parts of the loss function. This results in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"lesser overfitting\"), \".\"), mdx(\"p\", null, \"A great explanation for this can be found in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/fastai/fastbook/blob/master/13_convolutions.ipynb\"\n  }), \"chapter 13 of fastbook\"), \":\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"... a model that generalizes well is one whose loss would not change very much if you changed the input by a small amount. If a model trains at a large learning rate for quite a while, and can find a good loss when doing so, it must have found an area that also generalizes well, because it is jumping around a lot from batch to batch.\\n-- Deep Learning for Coders with fastai & PyTorch\")), mdx(Image, {\n    name: \"1cycle-vs-normal.png\",\n    mdxType: \"Image\"\n  }), mdx(\"p\", null, \"This comparison of test accuracies with super-convergence (in orange) and without it (in blue) shows how it allows us to train networks faster and with a higher test accuracy.\"), mdx(\"p\", null, \"According to the paper, this boost in performance due to super-convergence is even more prominent when the amount of training data is limited.\"), mdx(\"h2\", null, \"The regularizing effect of super-convergence\"), mdx(\"p\", null, \"Super-convergence is a combination of the 1cycle training policy and a high maximum learning rate. Using a high learning rate has a regularizing effect and we therefore need to reduce other forms of regularization such as batch sizes, weight decay and dropout.\"), mdx(\"p\", null, \"The paper specifically mentions that super-convergence was slightly more effective with larger batch sizes, since smaller batch sizes also have a regularizing effect (they are the \\\"stochastic\\\" in stochastic gradient descent).\"), mdx(\"h2\", null, \"Checking if super-convergence is possible\"), mdx(\"p\", null, \"The LR range test introduced by Leslie Smith in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://arxiv.org/abs/1506.01186\"\n  }), \"Cyclical Learning Rates for Training Neural Networks\"), \" can be used to determine if super-convergence is possible for a given neural network architecture.\"), mdx(\"p\", null, \"In the LR range test, we start training with a very small learning rate and linearly increase it up to a very large value and plot the loss or accuracy against the learning rate. Typically, there is a distinct peak in such a graph since the network converges with a low learning rate, and finally starts diverging as the learning rate becomes too large:\"), mdx(Image, {\n    name: \"lr-test-typical.png\",\n    mdxType: \"Image\"\n  }), mdx(\"p\", null, \"However, with certain architectures even when a very large learning rate is reached in the LR range test, the test accuracy remains consistently high:\"), mdx(Image, {\n    name: \"lr-test-super.png\",\n    mdxType: \"Image\"\n  }), mdx(\"p\", null, \"Network architectures that exhibit this kind of behavior have the potential of benefiting most from super-convergence.\"), mdx(\"h2\", null, \"The 1cycle policy in fastai\"), mdx(\"p\", null, \"Using the 1cycle training policy in fastai is extremely simple!\"), mdx(\"p\", null, \"Instances of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Learner\"), \" have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fit_one_cycle\"), \" method that allows you to train a network using the 1cycle policy.\"), mdx(\"p\", null, \"You can specify the maximum learning rate as a parameter to this method.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"learn = Learner(...)\\n\\n# Train for 10 epochs with a maximum learning rate of 0.06\\nlearn.fit_one_cycle(10, 0.06)\\n\")), mdx(\"p\", null, \"Yes, it's that simple!\"), mdx(\"p\", null, \"The 1cycle policy implemented in fastai is slightly different from the one described in the paper. Instead of linearly increasing and then linearly decreasing the learning rate, fastai uses an approach called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"cosine annealing\"), \":\"), mdx(Image, {\n    name: \"1cycle-fastai.png\",\n    mdxType: \"Image\"\n  }), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"We have looked at what super-convergence is and the benefits it brings. In particular, the ability to train networks faster and with a higher test accuracy, especially if the amount of labeled data for training is limited.\"), mdx(\"p\", null, \"We also saw how to use the 1cycle training policy with a high maximum learning rate to achieve super-convergence in theory, and how the use the policy practically using the fast.ai library.\"), mdx(\"p\", null, \"We also saw that since using a high learning rate has a regularizing effect, we need to minimize other forms of regularization we use.\"), mdx(\"h2\", null, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/fastai/fastbook/blob/master/13_convolutions.ipynb\"\n  }), \"Chapter 13: Deep Learning for Coders with fastai and PyTorch\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://arxiv.org/abs/1708.07120\"\n  }), \"Super-Convergence: Very Fast Training of Neural Networks Using Large Learning Rates\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://arxiv.org/abs/1506.01186\"\n  }), \"Cyclical Learning Rates for Training Neural Networks\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Understanding Super-Convergence"}}},"pageContext":{"id":"c8ae31f1-fd24-5d9c-9e4f-6253caebba70"}},"staticQueryHashes":["3069025275","63159454"]}